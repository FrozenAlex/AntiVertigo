# workflow name
name: NDK build

# run this workflow when
on:
  # user requests it ran manually
  workflow_dispatch:
  # there is files pushed
  push:
    # on branch master
    branches: master
    # ignore these  files
    paths-ignore:
      # ignore all .yml files
      - '**.yml'
      # dont ignore this specific file
      - '!.github/workflows/build-ndk.yml'
      # ignore all .json files
      - '**.json'
      # dont ignore this specific file
      - '!qpm.json'
      # ignore all .ps1 files
      - '**.ps1'
      # dont ignore these specific files
      - '!build.ps1'
      - '!buildQmod.ps1'
      - '!CreateQmod.ps1'
      # ignore all .md files
      - '**.md'
      # ignore the gitignore file
      - '.gitignore'
    # run this on a pr 
  pull_request:
    # on branch master
    branches: master

# set env variables
env:
    ndkname: android-ndk-r22
    module_id: antivertigo
    qmodName: AntiVertigo

# building a mod consists of a few steps

# what the fuck do we do
jobs:
  build:
    # os this runs on
    runs-on: ubuntu-latest
    
    # every step taken to complete this action
    # every - is a step that is traceable to a step on the github website
    steps:
      # tell the program it uses the checkout for actions (?)
    - uses: actions/checkout@v2
      name: Checkout
      with:
        submodules: recursive
        lfs: true

      # create the ndkpath.txt file needed in our own compile scripts
    - name: Create ndkpath.txt
      run: |
        echo "$ANDROID_NDK_LATEST_HOME" > ${GITHUB_WORKSPACE}/ndkpath.txt
        cat ${GITHUB_WORKSPACE}/ndkpath.txt
      # just "cat" the path into the ndkpath.txt

      # qpm caching, same as ndk but unused I assume
#     - name: Cache QPM
#       id: cache-qpm
#       uses: actions/cache@v2
#       env:
#         cache-name: cache-qpm
#       with:
#         path: QPM
#         key: ${{ runner.os }}-${{ env.cache-name }}-2
#         restore-keys: |
#           ${{ runner.os }}-${{ env.cache-name }}-2
      
    # we need qpm to even compile mods, since that is what we use to get packages
    - name: Get QPM
      # if it wasn't found in the cache
      if: steps.cache-qpm.outputs.cache-hit != 'true'
      uses: dawidd6/action-download-artifact@v2
      with:
        # download from the github actions
        github_token: ${{secrets.GITHUB_TOKEN}}
        workflow: cargo-build.yml
        name: linux-qpm-rust
        path: QPM
        repo: RedBrumbler/QuestPackageManager-Rust
      
    # collect all dependencies, I assume for reading back what was used to build a specific .so
    - name: QPM Collapse
      run: |
        mv ./QPM/qpm-rust ./QPM/QPM
        chmod +x ./QPM/QPM
        ./QPM/QPM collapse

    # unpack the cached QPM dependencies (packages)
    - name: QPM Dependencies Cache
      id: cache-qpm-deps
      uses: actions/cache@v2
      env:
        cache-name: cache-qpm-deps
      with:
        path: QPM_Temp
        key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('qpm.json') }}
        restore-keys: |
          ${{ runner.os }}-build-${{ env.cache-name }}-
          ${{ runner.os }}-build-
          ${{ runner.os }}-
      
    # run qpm restore
    - name: QPM Restore
#       if: steps.cache-qpm-deps.outputs.cache-hit != 'true'
      run: ./QPM/QPM restore
    
    #list what files are in the extern folder and in qpm temp folder
    - name: List Post Restore
      run: |
        echo includes:
        ls -la ${GITHUB_WORKSPACE}/extern/includes
        echo libs:
        ls -la ${GITHUB_WORKSPACE}/extern/libs
        ls -la $HOME/.local/share/QPM-Rust/cache
    
    # actually run the build script
    - name: Build debug
      run: |
        cd ${GITHUB_WORKSPACE}
        ./QPM/QPM qmod build
        pwsh -Command ./build.ps1
    
    #- name: Create Qmod
    #  run: |
    #    cd ${GITHUB_WORKSPACE}
    #    pwsh -Command ./CreateQmod.ps1

    # get the library name, by checking against the module ID
    - name: Get Library Name
      id: libname
      run: |
        cd ./build/
        pattern="lib${module_id}*.so"
        files=( $pattern )
        echo ::set-output name=NAME::"${files[0]}"
    
    #upload the debug .so
    - name: Upload debug artifact
      uses: actions/upload-artifact@v2
      with:
        name: debug_${{ steps.libname.outputs.NAME }}
        path: ./build/${{ steps.libname.outputs.NAME }}
        # if not found error obviously
        if-no-files-found: error

    # actually run the build script
    - name: Build release
      run: |
        cd ${GITHUB_WORKSPACE}
        pwsh -Command ./build.ps1 -release
    
    #upload the normal .so
    - name: Upload non-debug artifact
      uses: actions/upload-artifact@v2
      with:
        name: ${{ steps.libname.outputs.NAME }}
        path: ./build/${{ steps.libname.outputs.NAME }}
        # if not found error obviously
        if-no-files-found: error

    # upload the qmod 
#    - name: Upload qmod artifact
#      uses: actions/upload-artifact@v2
#      with:
#        name: ${{ env.qmodName }}.qmod
#        path: ./${{ env.qmodName }}.qmod
#        # if not found error obviously
#        if-no-files-found: error
    # TODO: Add auto-populating releases, auto update versions, auto publish package on release
